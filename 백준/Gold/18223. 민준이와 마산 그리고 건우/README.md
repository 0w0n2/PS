# [Gold IV] 민준이와 마산 그리고 건우 - 18223

[문제 링크](https://www.acmicpc.net/problem/18223)

### 📝 풀이 메모

해당 문제는 다음과 같은 **2가지 방식**으로 풀이하였습니다:

- **① 다익스트라 1회 사용 방식**  
  `./민준이와 마산 그리고 건우.java`
- **② 다익스트라 3회 사용 방식**  
  `./다익스트라3회_start노드와-end노드-반영.java`

---

### ✅ 방식 ①: 다익스트라 1회 사용 (상태 추적 방식)

- `Node` 클래스에 `isMet`(건우 P를 방문했는지 여부)를 저장하는 `boolean` 변수를 추가합니다.
- 최단 거리 배열 `dist`는 `[정점 번호][P 방문 여부]`를 기준으로 **2차원 배열**로 사용됩니다.
- `minCost`: 1번 노드에서 V번 노드까지의 일반 최단 거리  
  `minCostWithLayover`: 건우(P)를 들른 뒤 V번까지 가는 최단 거리
- 두 값 중 `minCostWithLayover == minCost` 인지를 비교함으로써,  
  **건우를 지나는 경로가 실제 최단 경로인지 여부**를 판별합니다.

---

### ✅ 방식 ②: 다익스트라 3회 사용 (구간별 분할 계산)

- `dist`는 일반적인 **1차원 배열**로 사용됩니다.
- 다익스트라 메소드를 세 번 호출하여, 각각의 구간 최단 경로를 계산합니다:
  - `1 → V`
  - `1 → P`
  - `P → V`
- 이후,  
  `dist(1 → V) == dist(1 → P) + dist(P → V)`  
  인지를 비교하여 **건우를 지나는 경로가 최단 경로와 같은지 여부**를 판단합니다.

---

### 📊 성능 비교 결과

| 방식             | 메모리 사용량 | 실행 시간 |
| ---------------- | ------------- | --------- |
| ① 상태 추적 방식 | 16,724 KB     | 152 ms    |
| ② 3회 호출 방식  | 17,204 KB     | 172 ms    |

✔️ ① 방식이 **메모리와 실행 시간 모두에서 더 효율적인 결과**를 보였습니다.

---

### 🔍 원인 분석

이러한 차이의 주요 원인은 다음과 같이 생각됩니다.

- **다익스트라 메소드가 3번 호출되면서** 내부의 PriorityQueue, dist 배열 등의 객체가 매번 **새롭게 생성되어 메모리 사용량이 증가**합니다.
- 또한 **중복된 경로 탐색이 발생**하기 때문에, 총 연산량 측면에서도 **① 방식이 더 효율적**입니다.
- 반면 ①은 **단일 탐색 과정에서 노드 P를 들렸는지 여부만 상태로 분리하여 추적**하므로 **불필요한 중복된 연산을 줄이고 메모리도 절약**할 수 있습니다.

---

> 💡 다만 문제에 따라 **복잡한 상태 추적이 필요 없는 경우에는**,  
> **다익스트라를 여러 번 분리해 호출하는 방식이 구현이 더 간단하고 명확해질 수 있습니다.**  
> 특히 경로의 정합성(1→P→V와 1→V의 거리 비교 등)이 중요한 경우에는 3회 호출 방식이 **더 직관적이고 안정적인 선택**이 될 수 있다고 생각합니다.
> <br>

### 성능 요약

메모리: 16724 KB, 시간: 152 ms

### 분류

그래프 이론, 최단 경로, 데이크스트라

### 제출 일자

2025년 6월 15일 02:00:51

### 문제 설명

<p>종강을 맞은 민준이는 고향인 마산으로 내려갈 계획을 짜고 있었다. 늘 그랬듯, 마산으로 갈 버스를 예약하려던 순간 민준이는 집으로 가는 다른 방법이 떠올랐다. 그것은 직접 지도를 보고 고향으로 가는 가장 짧은 길을 찾는 것이다.</p>

<p>그때, 먼저 고향으로 내려갔던 친구인 건우에게 연락이 왔다. 건우는 고향으로 내려가던 중 알 수 없는 일에 휘말려 외딴곳에 혼자 남겨지게 되었다. 건우는 유일한 구세주인 민준이에게 도움을 청한 것이었다. 그러나 마산의 남자인 민준이에게는 마산이 먼저였다. 민준이는 처량한 건우를 무시한 채 고향으로 떠나려고 했지만, 만약 고향으로 가는 길에 건우가 있다면 겸사겸사 도움을 줄 수 있을 것 같았다.</p>

<p>지도는 양방향 그래프 형태로 되어있다. 출발지는 1번 정점 마산은 V번 정점이다. 정점은 1~V까지 있다. 건우는 P번 정점에 있다.<br>
그리고 항상 1번 정점에서 P번과 V번 정점으로 갈 수 있는 경로가 존재한다.<br>
중복되는 간선과 자기 자신을 가리키는 간선은 존재하지 않는다.</p>

<p>아래와 같은 그래프가 있을 때,</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/202a6118-5a5c-462c-bce9-e9303701e63a/-/crop/724x635/187,35/-/preview/" style="height: 526px; width: 600px;"></p>

<p>위의 경우는 최단 경로가 두 가지 있다.<br>
1→3→4→5→6 또는 1→3→5→6 이다. 이것 중에서 건우가 있는 곳, 즉 4번 정점이 포함된 최단 경로가 있으므로 이 경우에는 민준이가 건우를 도울 수 있다.</p>

<p>민준이가 건우를 도와주는 경로의 길이가 최단 경로의 길이보다 길어지지 않는다면, 민준이는 반드시 건우를 도와주러 간다.</p>

<p>어쩌면 지킬 수도 있는 민준이의 우정을 위해 우리가 도와주자!</p>

### 입력

 <p>입력의 첫 번째 줄에 정점의 개수 V와 간선의 개수 E<em>,</em> 그리고 건우가 위치한 정점 P가 주어진다. (2 ≤ <em>V  </em>≤ 5,000, 1 ≤ <em>E </em>≤ 10,000, 1 ≤ <em>P  </em>≤ <em>V</em>)</p>

<p>두 번째 줄부터 E개의 줄에 걸쳐 각 간선의 정보 a,b,c가 공백으로 구분되어 주어진다. 이는 a번 정점과 b번 정점 사이의 거리가 c임을 의미한다. (1 ≤ <em>a</em>,<em>b </em>≤ <em>V</em>, 1 ≤ <em>c  </em>≤ 10,000)</p>

### 출력

 <p>민준이가 찾은 최단 경로 위에 건우가 있다면 "<code>SAVE HIM</code>" 을 아니면 "<code>GOOD BYE</code>" 를 출력한다.</p>
